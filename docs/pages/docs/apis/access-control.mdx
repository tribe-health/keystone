import { Markdown } from '../../../components/Markdown';

# Access Control API

The `access` property of the [list configuration](./schema) and [field configuration](./fields) objects configures who can query, create, update, and delete items in your Keystone system.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone';
import { text } from '@keystone-next/keystone/fields';

export default config({
  lists: createSchema({
    ListKey: list({
      fields: {
        fieldName: text({ access: { /* ... */ }, }),
      },
      access: { /* ... */ },
    }),
  }),
});
```

This document covers the complete access control API.
For a guide on how to use this API to apply common patterns please see the [access control guide](../guides/access-control).

## List Access Control

Keystone allows you to set up access control on a per-list basis.
The default access control is to allow all operations for all users.
Access control is applied to the generated CRUD (**c**reate, **r**ead, **u**pdate, **d**elete) operations and mutations in the [GraphQL API](./graphql), and is applied before any [hooks](./hooks) are executed.

List level access control can be specified in three ways, of increasing power.

- `operation` access control lets you check the information in the `context` and `session` objects to decide if the
  user is allow to access the list.
- `filter` access control lets you provide a GraphQL filter which defines the items the user is allowed to access.
- `item` access control lets you write a function which inspects the provided input data and the existing object (if it exists)
  and make a decision based on this extra data.

If access is denied due to any of the access control methods then the following response will be returned from the GraphQL API:

- **Mutations**
  - Single operations will return `null` and return an access denied error
  - Multi operations will return a data array with `null` values for the items which have access denied.
    Access denied errors will be return for each `null` items.
- **Queries**
  - Single item queries will return `null` with no errors.
  - Many item queries will filter out those items which have access denied, with no errors.
  - Count queries will only count those items for which access is not denied, with no errors.

### Operation

Operation level access control lets you control whether which operations can be accessed by a user based on the `session` and `context`.
Individual functions can be provided for each of the operations.
These functions must return `true` if the operation is allowed, or `false` if it is not allowed.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone';

export default config({
  lists: createSchema({
    ListKey: list({
      access: {
        operation: {
          query: ({ session, context, listKey, operation }) => true,
          create: ({ session, context, listKey, operation }) => true,
          update: ({ session, context, listKey, operation }) => true,
          delete: ({ session, context, listKey, operation }) => true,
        }
      },
    }),
  }),
});
```

?> The `query` access control rule is applied when running GraphQL query operations.
It does not prevent a user **reading** the data returned by the mutation operations.

### Filter

Filter level access control lets you control which operations can be performed by providing a function which returns a GraphQL filter.
For mutations, access will be denied if the item being operated on doesn't match the filter.
For queries, the access control filter will be combined with the provided query filter and only items which match both filters will be returned.

In general the filter access control functions will return GraphQL filters.
They can also return boolean values `true` or `false` to match or exclude all items.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone';
import { checkbox } from '@keystone-next/keystone/fields';

export default config({
  lists: createSchema({
    ListKey: list({
      fields: {
        isReadable: checkbox(),
        isUpdatable: checkbox(),
        isDeletable: checkbox(),
      }
      access: {
        filter: {
          query: ({ session, context, listKey, operation }) => {
            return { isReadable: { equals: true } };
          },
          update: ({ session, context, listKey, operation }) => {
            return { isUpdatable: { equals: true } };
          },
          delete: ({ session, context, listKey, operation }) => {
            return { isDeletable: { equals: true } };
          },
        }
      },
    }),
  }),
});
```

!> Filter access control cannot be used on `create` operations, as there is no pre-existing item to filter against.

### Item - Mutations only

The final level of access control is the `item` level.
This level of access control is available for the `create`, `update`, and `delete` mutations.
This level lets your write functions which have access to the input data of the mutation (for `create` and `update` operations) as well as the existing item in the database (for `update` and `delete` operations).
These functions must return `true` if the operation is allowed, or `false` if it is not allowed.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone';
import { checkbox } from '@keystone-next/keystone/fields';

export default config({
  lists: createSchema({
    ListKey: list({
      fields: {
        isReadable: checkbox(),
        isUpdatable: checkbox(),
        isDeletable: checkbox(),
      }
      access: {
        item: {
          create: ({ session, context, listKey, operation, originalInput }) => true,
          update: ({ session, context, listKey, operation, originalInput, item }) => true,
          delete: ({ session, context, listKey, operation, item }) => true,
        }
      },
    }),
  }),
});
```

### Function Arguments

List level access control functions are passed a collection of arguments which can be used to determine whether the operation is allowed.

| Argument        | Description                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------------------- |
| `session`       | The current session object. See the [Sessions API](./session) for details.                                    |
| `context`       | The [`KeystoneContext`](./context) object of the originating GraphQL operation.                               |
| `listKey`       | The key of the list being operated on.                                                                        |
| `operation`     | The operation being performed (`'query'`, `'create'`, `'update'`, `'delete'`).                                |
| `originalInput` | For `create` and `update` operations, this is the value of `data` passed into the mutation. (Item level only) |
| `item`          | The item being updated/deleted in `update` and `delete` operations. (Item level only)                         |

## Field Access Control

Keystone also allows you to set up access control on a per-field basis.
Access control rules can be set for `read`, `update` and `delete`operations.

Each operation is defined by a function which returns `true` if access is allowed and `false` if access is not allowed.

- **Mutations**: The field level access control rules are applied after the list level access rules have been applied.
  Only those fields which have an input value provided to the mutation will have their access control rules applied.
  If any of the provided fields fail their access control check, then the whole operation will be aborted.
  The GraphQL API will return `null` along with an access denied error.

- **Queries**: Field level access control rules are applied when trying to resolve a field on the output type.
  If access is denied then the query will still return an item object, but the specific field will return `null`.
  No errors will be returned for `read` access denied.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone';
import { text } from '@keystone-next/keystone/fields';

export default config({
  lists: createSchema({
    ListKey: list({
      fields: {
        fieldName: text({
          access: {
            read: ({ session, context, listKey, fieldKey, operation, item }) => true,
            create: ({ session, context, listKey, fieldKey, operation, originalInput }) => true,
            update: ({ session, context, listKey, fieldKey, operation, originalInput, item }) => true,
          },
        }),
      },
    }),
  }),
});
```

!> Field level access control is not available for `delete` operations.

### Function Arguments

Field level access control functions are passed a collection of arguments which can be used to determine whether the operation is allowed.

| Argument        | Description                                                                                 |
| --------------- | ------------------------------------------------------------------------------------------- |
| `session`       | The current session object. See the [Sessions API](./session) for details.                  |
| `context`       | The [`KeystoneContext`](./context) object of the originating GraphQL operation.             |
| `listKey`       | The key of the list being operated on.                                                      |
| `fieldKey`      | The key of the field being operated on.                                                     |
| `operation`     | The operation being performed (`'read'`, `'create'`, `'update'`).                           |
| `originalInput` | For `create` and `update` operations, this is the value of `data` passed into the mutation. |
| `item`          | The item being read/updated in `read` and `update` operations.                              |

export default ({ children }) => <Markdown description="Complete reference docs for Keystone’s Access Control API. Configure who can read, create, update, and delete items in your Keystone system.">{children}</Markdown>;
